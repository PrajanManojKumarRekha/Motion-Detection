<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Pose Playback</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            color: rgb(255, 255, 255);
        }
        #fileInput { margin-bottom: 10px; }
        #playback {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        button {
            padding: 8px 15px;
            cursor: pointer;
            background: #00d9ff;
            border: none;
            border-radius: 4px;
            color: black;
            font-weight: bold;
        }
        button:hover { background: #00b8dd; }
        #frameInfo { margin-top: 10px; font-size: 12px; }
    </style>
</head>
<body>
    <div id="controls">
        <input type="file" id="fileInput" accept=".json">
        <div id="playback" style="display: none;">
            <button id="playBtn">Play</button>
            <button id="pauseBtn">Pause</button>
            <input type="range" id="frameSlider" min="0" max="100" value="0" style="width: 200px;">
        </div>
        <div id="frameInfo"></div>
    </div>

    <script>
        let scene, camera, renderer;
        let mannequinParts = {};
        let sequenceData = [];
        let currentFrame = 0;
        let isPlaying = false;
        let frameSkip = 3;
        let frameCounter = 0;

        const LANDMARK_INDICES = {
            nose: 0, leftShoulder: 11, rightShoulder: 12,
            leftElbow: 13, rightElbow: 14, leftWrist: 15, rightWrist: 16,
            leftHip: 23, rightHip: 24, leftKnee: 25, rightKnee: 26,
            leftAnkle: 27, rightAnkle: 28, leftFootIndex: 31, rightFootIndex: 32
        };

        function getPosition(frameData, landmarkIndex) {
            const scale = 2;
            let x = frameData[landmarkIndex * 3] * scale;
            const y = -frameData[landmarkIndex * 3 + 1] * scale;
            const z = frameData[landmarkIndex * 3 + 2] * scale;
            
            x-=1;
         
            if (x > 0) x *= 1.7;
            else if (x < 0) x *= 1.7;
            
            return new THREE.Vector3(x, y, z);
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(2, 0, 3);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(5, 10, 5);
            mainLight.castShadow = true;
            scene.add(mainLight);

            const groundGeometry = new THREE.PlaneGeometry(10, 10);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x0f3460 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.position.y = -1.8;
            scene.add(ground);

            const gridHelper = new THREE.GridHelper(10, 20, 0xFF0000, 0xFF0000);
            gridHelper.position.y = -2;
            scene.add(gridHelper);

            createMannequin();

            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let cameraAngle = { theta: 0, phi: 0 };
            let cameraDistance = 2.5;

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    
                    cameraAngle.theta += deltaX * 0.01;
                    cameraAngle.phi += deltaY * 0.01;
                    cameraAngle.phi = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraAngle.phi));
                    
                    updateCamera();
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                cameraDistance += e.deltaY * 0.001;
                cameraDistance = Math.max(1, Math.min(5, cameraDistance));
                updateCamera();
            });

            function updateCamera() {
                camera.position.x = cameraDistance * Math.sin(cameraAngle.theta) * Math.cos(cameraAngle.phi);
                camera.position.y = cameraDistance * Math.sin(cameraAngle.phi);
                camera.position.z = cameraDistance * Math.cos(cameraAngle.theta) * Math.cos(cameraAngle.phi);
                camera.lookAt(0, 0, 0);
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createMannequin() {
            const skinMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFADADD, roughness: 0.5, metalness: 0.1
            });
            const jointMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFC0CB, roughness: 0.3, metalness: 0.3
            });

            mannequinParts.head = createSphere(0.12, skinMaterial);
            mannequinParts.neck = createCylinder(0.05, 0.13, skinMaterial);
            mannequinParts.upperTorso = createCylinder(0.15, 0.25, skinMaterial);
            mannequinParts.lowerTorso = createCylinder(0.13, 0.2, skinMaterial);
            
            mannequinParts.leftShoulder = createSphere(0.06, jointMaterial);
            mannequinParts.rightShoulder = createSphere(0.06, jointMaterial);
            mannequinParts.leftUpperArm = createCylinder(0.05, 0.25, skinMaterial);
            mannequinParts.rightUpperArm = createCylinder(0.05, 0.25, skinMaterial);
            mannequinParts.leftElbow = createSphere(0.05, jointMaterial);
            mannequinParts.rightElbow = createSphere(0.05, jointMaterial);
            mannequinParts.leftForearm = createCylinder(0.04, 0.25, skinMaterial);
            mannequinParts.rightForearm = createCylinder(0.04, 0.25, skinMaterial);
            mannequinParts.leftWrist = createSphere(0.04, jointMaterial);
            mannequinParts.rightWrist = createSphere(0.04, jointMaterial);
            mannequinParts.leftHand = createSphere(0.05, skinMaterial);
            mannequinParts.rightHand = createSphere(0.05, skinMaterial);
            
            mannequinParts.leftHip = createSphere(0.06, jointMaterial);
            mannequinParts.rightHip = createSphere(0.06, jointMaterial);
            mannequinParts.leftThigh = createCylinder(0.07, 0.2, skinMaterial);
            mannequinParts.rightThigh = createCylinder(0.07, 0.2, skinMaterial);
            mannequinParts.leftKnee = createSphere(0.05, jointMaterial);
            mannequinParts.rightKnee = createSphere(0.05, jointMaterial);
            mannequinParts.leftShin = createCylinder(0.05, 0.2, skinMaterial);
            mannequinParts.rightShin = createCylinder(0.05, 0.2, skinMaterial);
            mannequinParts.leftAnkle = createSphere(0.05, jointMaterial);
            mannequinParts.rightAnkle = createSphere(0.05, jointMaterial);
            
            const footGeometry = new THREE.BoxGeometry(0.08, 0.06, 0.15);
            mannequinParts.leftFoot = new THREE.Mesh(footGeometry, skinMaterial);
            mannequinParts.rightFoot = new THREE.Mesh(footGeometry, skinMaterial);

            Object.values(mannequinParts).forEach(part => {
                part.castShadow = true;
                scene.add(part);
            });
        }

        function createCylinder(radius, height, material) {
            const geometry = new THREE.CylinderGeometry(radius, radius, height, 16);
            return new THREE.Mesh(geometry, material);
        }

        function createSphere(radius, material) {
            const geometry = new THREE.SphereGeometry(radius, 16, 16);
            return new THREE.Mesh(geometry, material);
        }

        function positionCylinderBetween(cylinder, start, end) {
            const direction = new THREE.Vector3().subVectors(end, start);
            const length = direction.length();
            const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
            cylinder.position.copy(center);
            cylinder.scale.y = length / 0.25;
            cylinder.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.normalize());
        }

        function updateMannequin() {
            if (sequenceData.length === 0 || currentFrame >= sequenceData.length) return;

            const frameData = sequenceData[currentFrame];
            const hasValidPose = frameData.some(val => val !== 0);
            
            if (!hasValidPose) {
                Object.values(mannequinParts).forEach(part => part.visible = false);
                return;
            }

            Object.values(mannequinParts).forEach(part => part.visible = true);

            const nose = getPosition(frameData, LANDMARK_INDICES.nose);
            const leftShoulder = getPosition(frameData, LANDMARK_INDICES.leftShoulder);
            const rightShoulder = getPosition(frameData, LANDMARK_INDICES.rightShoulder);
            const leftElbow = getPosition(frameData, LANDMARK_INDICES.leftElbow);
            const rightElbow = getPosition(frameData, LANDMARK_INDICES.rightElbow);
            const leftWrist = getPosition(frameData, LANDMARK_INDICES.leftWrist);
            const rightWrist = getPosition(frameData, LANDMARK_INDICES.rightWrist);
            const leftHip = getPosition(frameData, LANDMARK_INDICES.leftHip);
            const rightHip = getPosition(frameData, LANDMARK_INDICES.rightHip);
            const leftKnee = getPosition(frameData, LANDMARK_INDICES.leftKnee);
            const rightKnee = getPosition(frameData, LANDMARK_INDICES.rightKnee);
            const leftAnkle = getPosition(frameData, LANDMARK_INDICES.leftAnkle);
            const rightAnkle = getPosition(frameData, LANDMARK_INDICES.rightAnkle);
            const leftFootIndex = getPosition(frameData, LANDMARK_INDICES.leftFootIndex);
            const rightFootIndex = getPosition(frameData, LANDMARK_INDICES.rightFootIndex);

            const shoulderCenter = new THREE.Vector3().addVectors(leftShoulder, rightShoulder).multiplyScalar(0.5);
            const hipCenter = new THREE.Vector3().addVectors(leftHip, rightHip).multiplyScalar(0.5);
            const torsoMid = new THREE.Vector3().lerpVectors(shoulderCenter, hipCenter, 0.5);

            mannequinParts.head.position.copy(nose);
            positionCylinderBetween(mannequinParts.neck, nose, shoulderCenter);
            positionCylinderBetween(mannequinParts.upperTorso, shoulderCenter, torsoMid);
            positionCylinderBetween(mannequinParts.lowerTorso, torsoMid, hipCenter);

            mannequinParts.leftShoulder.position.copy(leftShoulder);
            mannequinParts.rightShoulder.position.copy(rightShoulder);
            positionCylinderBetween(mannequinParts.leftUpperArm, leftShoulder, leftElbow);
            positionCylinderBetween(mannequinParts.rightUpperArm, rightShoulder, rightElbow);
            mannequinParts.leftElbow.position.copy(leftElbow);
            mannequinParts.rightElbow.position.copy(rightElbow);
            positionCylinderBetween(mannequinParts.leftForearm, leftElbow, leftWrist);
            positionCylinderBetween(mannequinParts.rightForearm, rightElbow, rightWrist);
            mannequinParts.leftWrist.position.copy(leftWrist);
            mannequinParts.rightWrist.position.copy(rightWrist);
            mannequinParts.leftHand.position.copy(leftWrist);
            mannequinParts.rightHand.position.copy(rightWrist);

            mannequinParts.leftHip.position.copy(leftHip);
            mannequinParts.rightHip.position.copy(rightHip);
            positionCylinderBetween(mannequinParts.leftThigh, leftHip, leftKnee);
            positionCylinderBetween(mannequinParts.rightThigh, rightHip, rightKnee);
            mannequinParts.leftKnee.position.copy(leftKnee);
            mannequinParts.rightKnee.position.copy(rightKnee);
            positionCylinderBetween(mannequinParts.leftShin, leftKnee, leftAnkle);
            positionCylinderBetween(mannequinParts.rightShin, rightKnee, rightAnkle);
            mannequinParts.leftAnkle.position.copy(leftAnkle);
            mannequinParts.rightAnkle.position.copy(rightAnkle);

            const leftFootDir = new THREE.Vector3().subVectors(leftFootIndex, leftAnkle);
            mannequinParts.leftFoot.position.copy(leftAnkle).add(leftFootDir.multiplyScalar(0.5));
            mannequinParts.leftFoot.lookAt(leftFootIndex);

            const rightFootDir = new THREE.Vector3().subVectors(rightFootIndex, rightAnkle);
            mannequinParts.rightFoot.position.copy(rightAnkle).add(rightFootDir.multiplyScalar(0.5));
            mannequinParts.rightFoot.lookAt(rightFootIndex);
        }

        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                sequenceData = JSON.parse(event.target.result);
                currentFrame = 0;
                document.getElementById('frameSlider').max = sequenceData.length - 1;
                document.getElementById('playback').style.display = 'flex';
                updateFrameInfo();
            };
            reader.readAsText(file);
        });

        document.getElementById('playBtn').addEventListener('click', () => { isPlaying = true; });
        document.getElementById('pauseBtn').addEventListener('click', () => { isPlaying = false; });
        document.getElementById('frameSlider').addEventListener('input', (e) => {
            currentFrame = parseInt(e.target.value);
            updateFrameInfo();
        });

        function updateFrameInfo() {
            document.getElementById('frameInfo').textContent = 
                `Frame: ${currentFrame + 1} / ${sequenceData.length}`;
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isPlaying && sequenceData.length > 0) {
                frameCounter++;
                if (frameCounter >= frameSkip) {
                    frameCounter = 0;
                    currentFrame++;
                    if (currentFrame >= sequenceData.length) currentFrame = 0;
                    document.getElementById('frameSlider').value = currentFrame;
                    updateFrameInfo();
                }
            }

            updateMannequin();
            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>